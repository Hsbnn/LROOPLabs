## Лабораторная работа №7


### {Асинхронное программирование} 

```c++
std::lock_guard<std::mutex> lck(print_mutex);
```
```c++
std::this_thread::sleep_for(1s);
```
```c++
std::lock_guard<std::shared_mutex> lock(mtx);
```

#### Вариант 5

> Знакомство с асинхронным программированием;

> Получение практических навыков в параллельной обработке данных;

> Получение практических навыков в синхронизации потоков;


Должно быть реализовано три потока:

o Поток, который осуществляет передвижение NPC на определенное расстояние 
(см. таблицу), а также определяет, что два NPC находятся на расстоянии убийства
(см. таблицу). Если два NPC вступили в «бой», то он создает задачу для потока, 
осуществляющего бои.

o Поток, который осуществляет бои. Если один npc может убивать другой, то 
каждый npc «кидает 6-гранный кубик» определяя силу атаки и силу защиты 
(соответственно). Если сила атаки больше, чем сила защиты – то происходит 
убийство.

o Мертвые npc не передвигаются (у нас тут без некромантов).

o Живые npc не могут покинуть карту (размер задается через константы, например 
100 x 100)

o Основной поток раз в секунду печатает карту. Мертвые npc на карте не 
отображаются.

• Осуществить контроль доступа к разделяемым ресурсов с помощью std::shared_lock и 
std::lock_guard

• Осуществить контроль к потоку вывода std::cout через std::lock_guard

• Потоки могут запускаться как std::thread с использованием лямбда функций или 
функторов (классов с перегруженным оператором operator())

• Вначале игры должно создаваться 50 npc в случайных локациях.

• Игра должна останавливаться через 30 секунд и выводить на экран список выживших

